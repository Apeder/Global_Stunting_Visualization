<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="utf-8">
	<title>Choropleth Madness</title>
	  <style>
	  #wrapper {
	  	width: 1200px;
	  	margin: -50px auto 0;
	  }
	  #map {
	  	width: 1000px;
	  	height: 580px;
	  	position: relative;
	  }
	  .stroke {
	  	fill: none;
	  	stroke: #888;
	  	stroke-width: 2px;
	  }
	  .fill {
	  	fill: #fff;
	  }
	  .land {
	  	fill: #222;
	  }
	  .boundary {
	  	fill: none;
	  	stroke: #fff;
	  	stroke-width: .5px;
	  }
	  .country {
	  	fill: red;
	  	stroke: white;
	  }
	  #play, #clock {
	  	position: absolute;
	  	top: 15px;
	  }
	  #play {
	  	left: 15px;
	  }
	  #clock {
	  	left: 65px;
	  }
	  </style>
	</head>

	<body>
		<div id="wrapper">
			<div id="map"></div>
			<button id="play">play</button>
			<span id="clock">year</span>
		</div>

	  <script src="http://d3js.org/d3.v4.min.js"></script>
	  <script src="https://d3js.org/d3-scale.v1.min.js"></script>
	  <script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>
	  <script src="https://d3js.org/queue.v1.min.js"></script>
	  <script src="https://d3js.org/topojson.v1.min.js"></script>
	  <script type="text/javascript">
	  	
	  	var width, height, attributeArray = [], projection, currentAttribute = 0, playing = false, path, svg;

	  	function init() {

	  		setMap();
	  		animateMap();
	  	}

	  	function setMap() {
	 
	  		width = 1000, height = 580;
	  	
		  	var projection = d3.geoMercator()
		  							.scale(200) 
		  							.translate([width / 2.2, height / 1.9])
		  							.precision(.1);

		  	path = d3.geoPath().projection(projection);

		  	svg = d3.select("#map").append("svg")
		  		.attr("width", width)
		  		.attr("height", height);

		  	loadData();

	  	}

	  	function loadData() {
	  
	  		queue()
	  			.defer(d3.json, "worldtopo.json")
	  			.defer(d3.csv, "Data/clean_analysis/world_stunting.csv")
	  			.await(processData);
	  	}

	  	function processData(error,globe,world_info) {
	  		var countries = globe.objects.countries_not_ata.geometries;
	  		for (var i in countries) {
	  			for (var j in world_info) {
	  				if(countries[i].properties.id == world_info[j].ISO_country) {
	  					countries[i].properties.matched = true
	  					// console.log(world_info[j].ISO_country, j, i)
	  					for(var k in world_info[j]) {
	  						if(k != 'ISO_country') {
	  							if(attributeArray.indexOf(k) == -1) {
	  								attributeArray.push(k)
	  							}
	  							countries[i].properties[k] = Number(world_info[j][k])
	  						}
	  					}
	  					break;
	  				}
	  			}
	  			if (!countries[i].properties.matched) {
	  				for (var k in world_info[1]) {
	  					countries[i].properties[k] = 0
	  				}
	  			}
	  		}
	  		// console.log(countries)		
	  		d3.select('#clock').html(attributeArray[currentAttribute]);
	  		map_data(globe);	
	  	}

	  	function map_data(globe) {

	  		svg.selectAll(".country")
	  			.data(topojson.feature(globe, globe.objects.countries_not_ata).features)
	  			.enter().append("path")
	  			.attr("class", "country")
	  			.attr("id", function(d) { return "code_" +d.properties.id; }, true)
	  			.attr('d', path);

	  		var dataRange = [0,100] 
	  		// var dataRange = getDataRange();
	  		
	  		d3.selectAll('.country')
	  			.attr('fill-opacity', function(d) {
	  				if(d.properties[attributeArray[currentAttribute]] != 0 || d.properties.matched==false) {
	  					return getColor(d.properties[attributeArray[currentAttribute]], dataRange)}
	  				else {
	  					return 0
	  				}
	  			});	
	  	}

	  	function sequenceMap() {

	  		var dataRange = [0,100] 
	  		// var dataRange = getDataRange();

	  		d3.selectAll('.country').filter(function(d) {return d.properties[attributeArray[currentAttribute]] != 0})
	  								.transition()
	  								.duration(700)
	  								// .style("color", "red")
	  								.attr('fill-opacity', function(d) {
	  									// if(d.properties[attributeArray[currentAttribute]] != 0 || d.properties.matched==false) {
	  									// 	return getColor(d.properties[attributeArray[currentAttribute]], dataRange);
	  									// }
	  									// else {
	  										for(var i=attributeArray.length; i--;) {
	  											if(d.properties[attributeArray[i]] != 0 && attributeArray[i] >=1983 && attributeArray[i] <=attributeArray[currentAttribute]) {
	  												return getColor(d.properties[attributeArray[i]], dataRange)}
	  											// else {
	  											// 	return 0};
	  										
	  										// j = 0
	  										// if(d.properties[attributeArray[i]]=0) {
	  										// 	j +=1
	  										// }
	  										// if(d[j] = 32) {
	  										// 	return getColor(0, dataRange)
	  										// }
	  									// }
	  								}
	  							});

	  		// console.log(svg.selectAll('.country'))
	  	}

	  	function getColor(valueIn, valuesIn) {

	  		var color = d3.scaleLinear()
		  		.domain([valuesIn[0],valuesIn[1]])
		  		.range([0, 1]);

		  	return color(valueIn);
	  	}
	  	
	  	// function getDataRange() {

	  	// 	var min = Infinity, max = -Infinity;
	  	// 	d3.selectAll('.country')
	  	// 		.each(function(d,i) {
	  	// 			var currentValue = d.properties[attributeArray[currentAttribute]];
	  	// 			if(currentValue <= min && currentValue != -99 && currentValue != 'undefined') {
	  	// 				min = currentValue;
	  	// 			}
	  	// 		if(currentValue >= max && currentValue != -99 && currentValue != 'undefined') {
	  	// 			max = currentValue;
	  	// 		}
	  	// 	});
	  	// 	return [min,max];
	  	// }
	  	
	  	function animateMap() {

	  		var timer; 
	  		d3.select('#play')
	  			.on('click', function() {
	  				if(playing == false) {
	  					timer = setInterval(function() {
	  						if(currentAttribute < attributeArray.length-1) {
	  							currentAttribute +=1;
	  						} else {
	  							currentAttribute = 0;
	  						}
	  						sequenceMap();
	  						d3.select('#clock').html(attributeArray[currentAttribute]);
	  					}, 2000);

	  					d3.select(this).html('stop');
	  					playing = true;
	  				} else {
	  					clearInterval(timer);
	  					d3.select(this).html('play');
	  					playing = false;
	  				}
	  			});
	  	} 

	  	window.onload = init();

  </script>
</body>
</html>