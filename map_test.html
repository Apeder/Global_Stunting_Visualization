<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="utf-8">
	<title>Choropleth Madness</title>
	  <style>
	  #wrapper {
	  	width: 960px;
	  	margin: -30px auto 0;
	  }
	  #map {
	  	width: 960px;
	  	height: 580px;
	  	position: relative;
	  }
	  .stroke {
	  	fill: none;
	  	stroke: #888;
	  	stroke-width: 2px;
	  }
	  .fill {
	  	fill: #fff;
	  }
	  .graticule {
        fill: none;
        stroke: #777;
        stroke-width: .5px;
        stroke-opacity: .5;
      }
	  .land {
	  	fill: #222;
	  }
	  .boundary {
	  	fill: none;
	  	stroke: #fff;
	  	stroke-width: .5px;
	  }
	  .country {
	  	fill: steelblue;
	  	stroke: black;
	  }
	  #play, #clock {
	  	position: absolute;
	  	top: 15px;
	  }
	  #play {
	  	left: 15px;
	  }
	  #clock {
	  	left: 65px;
	  }
	  </style>
	</head>

	<body>
		<div id="wrapper">
			<div id="map"></div>
			<button id="play">play</button>
			<span id="clock">year</span>
		</div>

	  <script src="http://d3js.org/d3.v4.min.js"></script>
	  <script src="https://d3js.org/queue.v1.min.js"></script>
	  <script src="https://d3js.org/topojson.v1.min.js"></script>
	  <script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>
	  <script src="https://d3js.org/d3-array.v1.min.js"></script>
	  <script src="https://d3js.org/d3-geo.v1.min.js"></script>
	  <script type="text/javascript">
	  	var width, height, attributeArray = [], projection, graticule, currentAttribute = 0, playing = false, path, svg;

	  	function init() {

	  		setMap();
	  		animateMap();
	  	}

	  	function setMap() {
	 
	  		width = 960, height = 580;
	  	
		  	var projection = d3.geoEckert5()
		  							.scale(170) 
		  							.translate([width / 2, height / 2])
		  							.precision(.1);

		  	path = d3.geoPath().projection(projection);

		  	graticule = d3.geoGraticule();

		  	svg = d3.select("#map").append("svg")
		  		.attr("width", width)
		  		.attr("height", height);
		  	
		  	svg.append("defs").append("path")
		  		.datum({type: "Sphere"})
		  		.attr("id", "sphere")
		  		.attr("d", path);

		  	svg.append("use")
		  		.attr("class", "stroke")
		  		.attr("xlink:href", "#sphere");

		  	svg.append("path")
		  		.datum(graticule)
		  		.attr("class", "graticule")
		  		.attr("d", path);

		  	loadData();

	  	}

	  	function loadData() {
	  		queue()
	  			.defer(d3.json, "map_test.json")
	  			.defer(d3.csv, "countriesRandom.csv")
	  			.await(processData);
	  	}

	  	function processData(error,globe,world_info) {
	  		var countries = globe.objects.countries.geometries;
	  		for (var i in countries) {
	  			for (var j in world_info) {
	  				if(countries[i].properties.id == world_info[j].id) {
	  					for(var k in world_info[i]) {
	  						if(k != 'name' && k != 'id') {
	  							if(attributeArray.indexOf(k) == -1) {
	  								attributeArray.push(k)
	  							}
	  							countries[i].properties[k] = Number(world_info[j][k])
	  						}
	  					}
	  					break;
	  				}
	  			}
	  		}
	  		d3.select('#clock').html(attributeArray[currentAttribute]);
	  		map_data(globe);	
	  	}

	  	function map_data(globe) {

	  		svg.selectAll(".country")
	  			.data(topojson.feature(globe, globe.objects.countries).features)
	  			.enter().append("path")
	  			.attr("class", "country")
	  			.attr("id", function(d) { return "code_" +d.properties.id; }, true)
	  			.attr("d", path);

	  		var dataRange = getDataRange();
	  		d3.selectAll('.country')
	  			.attr('fill-opacity', function(d) {
	  				return getColor(d.properties[attributeArray[currentAttribute]], dataRange);
	  			});	
	  	}

	  	function sequenceMap() {

	  		var dataRange = getDataRange();
	  		d3.selectAll('.country').transition()
	  								.duration(750)
	  								.attr('fill-opacity', function(d) {
	  									return getColor(d.properties[attributeArray[currentAttribute]], dataRange);
	  								});
	  	}
	  	
	  	function getColor(v1, v2) {

	  		var color = d3.scaleLinear()
		  		.domain([v2[0],v2[1]])
		  		.range([.3,1]);

		  	return color(v1)
	  	}

	  	function getDataRange() {

	  		var min = Infinity, max = -Infinity;
	  		d3.selectAll('.country')
	  			.each(function(d,i) {
	  				var currentValue = d.properties[attributeArray[currentAttribute]];
	  				if(currentValue <= min && currentValue != -99 && currentValue != 'undefined') {
	  					min = currentValue;
	  			}
	  			if(currentValue >= max && currentValue != -99 && currentValue != 'undefined') {
	  				max = currentValue;
	  			}
	  			});
	  		return [min,max]
	  	}
	  	function animateMap() {

	  		var timer; 
	  		d3.select('#play')
	  			.on('click', function() {
	  				if(playing == false) {
	  					timer = setInterval(function() {
	  						if(currentAttribute < attributeArray.length-1) {
	  							currentAttribute +=1;
	  						} else {
	  							currentAttribute = 0;
	  						}
	  						sequenceMap();
	  						d3.select('#clock').html(attributeArray[currentAttribute]);
	  					}, 2000);

	  					d3.select(this).html('stop');
	  					playing = true;
	  				} else {
	  					clearInterval(timer);
	  					d3.select(this).html('play');
	  					playing = false;
	  				}
	  			});
	  	} 

	  	window.onload = init();

  </script>
</body>
</html>